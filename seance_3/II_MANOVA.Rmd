---
title: "<FONT color='#0066CC'><FONT size = 4 ><DIV align= center> AP-4209 ESIEE-Paris: 2023 -2024 </DIV></FONT></FONT>"
output:
  html_document:
    highlight: textmate
    theme: readable
    toc: yes
    toc_depth: 6
    toc_float: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
body, td {font-size: 15px;}
code.r{font-size: 5px;}
pre { font-size: 12px;}
</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<FONT color='#0066CC'><FONT size = 4 >

::: {align="center"}
Fouille de données avec R pour la data science et l'intelligence
artificielle\

III.TD 3 : Partie I - MANOVA
:::

</FONT></FONT>

<FONT color='#0066CC'><FONT size = 4 >

::: {align="center"}
Badr TAJINI -- ESIEE Paris\
Source : Bertrand Roudier -- ESIEE Paris
:::

</FONT></FONT>

<hr style="border: 1px  solid gray">

</hr>

<DIV align = justify>

### <FONT color='#0066CC'><FONT size = 4> 1. Introduction </FONT></FONT>

Ce TD a pour objectif de réaliser une analyse de variance multivariée
(MANOVA) en développant une fonction dédiée. Nous utilisons dans un
premier temps un jeu de données simple (exemple vu en cours) ou tous les
résultats intermédiaires vous sont fournis.

Une fois votre code intégré dans une fonction, vous vérifiez vos
résultats en comparaison avec les résultats fournis par la fonction
*manova* de R sur un jeu de données de volumétrie plus importante.

Une partie du code que vous allez développer nous servira pour la suite
lorsque nous aborderons l'analyse factorielle discriminante ;
principalement le calcul des inerties inter classes, intra classes et
totales

<br>

<hr style="border: 1px  solid gray">

### <FONT color='#0066CC'><FONT size = 4> 2 Rappels </FONT></FONT>

La somme des carrés des écarts total (SCT = Inertie Totale) est la
résultante (comme en ANOVA) de la sommes des carrés intra classes
(SCresiduelle = SC Intra ) et de la somme des carrés inter classes (SC
Ecart = SC Inter)
$$\sum\limits_{i = 1}^n {{d^2}({x_i},g)}  = \sum\limits_{j = 1}^k {{n_j}{d^2}} ({g_j},g) + \sum\limits_{j = 1}^k {\sum\limits_{i = 1}^{{n_k}} {{d^2}({x_{i,j}},{g_j})} } $$

Si nous considérons le jeu de données comme étant la population, nous
pouvons directement estimer les variances inter classes et intra classes
:
$$\frac{1}{n}\sum\limits_{i = 1}^n {{d^2}({x_i},g)}  = \frac{1}{n}\sum\limits_{j = 1}^k {{n_j}{d^2}} ({g_j},g) + \frac{1}{n}\sum\limits_{j = 1}^k {\sum\limits_{i = 1}^{{n_k}} {{d^2}({x_{i,j}},{g_j})} } $$
Pour réaliser le test de comparaison des groupes, nous calculons

1.  la somme des carrés Totaux: *SST*
2.  La somme des carrés Intra: *SS intra*
3.  La somme des carrés Inter par différence : *SS inter = SS Tot - SS
    intra*
4.  la ratio des déterminants: *Det(SS intra) / Det(SS total)*
5.  La valeur critique qui suit une distribution de *Chi-Deux* et qui
    nous permet de réaliser le test

<br>

<hr style="border: 1px  solid gray">

### <FONT color='#0066CC'><FONT size = 4> 3 Pré-requis </FONT></FONT>

Avant de calculer les inerties (SS), et pour rendre le code le plus
générique possible, nous devons créer :

-   Une variable *N* qui correspond aux nombre totale d'individus
-   Une variable *P* qui correspond aux nombres de variables
-   Un data frame des variables prédictives *X*
-   Un vecteur *Y* de la variable catégorielle
-   Une variable *K* qui correspond aux nombres de groupes (catégories)\
-   Une liste *XK* dont chaque élément contient les individus de chaque
    groupes
-   Un vecteur *NK* qui correspond aux nombres d'individus par groupe
-   Une liste *GK* dont chaque élément contient la moyenne des variables
    de chaque groupe (catégorie)
-   Un vecteur *G* dont chaque élément est la moyenne générale (hors
    groupe) de chaque variable

Nous utilisons le fichier : *MANOVA_DATASET.csv*. Ce jeu de données
comprend

-   26 observations\
-   5 variables explicatives numériques
-   1 variable factorielle comprenant 4 niveaux (catégories) \> Note :
    le fichier **MANOVA_DATASET.csv** doit être transformé en fichier
    **MANOVA_DATASET.Rda** pour être utilisé dans votre TD correctement.

rmq: Il s'agit ici d'étudier l'existence d'une différence entre la
composition chimique de différentes des poteries antiques retrouvées
dans des fouilles archéologiques.

-   **Installation des packages nécessaires :**\

```{r}
# load(...)
```

-   **Chargement des packages nécessaires :**

```{r}
rm(list = ls())       # initialisation
library(kableExtra)   # chargement du paquet
library(tidyverse)
library(dplyr)
library(readr)
```

-   **Première étape :**

```{r}
# MANOVA_DATASET <- read_csv("MANOVA_DATASET.csv")
# save(MANOVA_DATASET, file = "MANOVA_DATASET.Rda") # ? 
```

-   **Seconde étape :**

```{r}
df_MANOVA <- read(file = "MANOVA_DATASET.Rda")
```

-   **Troisième étape :**

Les données sont les suivantes :

```{r,echo = T,  warning = F}
MANOVA_DATASET %>% kbl(digits=3) %>%    
       kable_styling(bootstrap_options = "striped", full_width = T, position = "center", latex_options = 'stripped')
```

-   **Quatrième étape :**

```{r,   warning = F}
MANOVA_DATASET$Site <- as.factor(MANOVA_DATASET$Site)

```

-   **Cinquième étape :**

```{r,   warning = F}
class(MANOVA_DATASET)
typeof(MANOVA_DATASET)
typeof(MANOVA_DATASET$Site) # pourquoi c'est un int ? 
str(MANOVA_DATASET)
```

-   **Sixième étape :**

```{r,echo = T,  warning = F}
col <- names(MANOVA_DATASET[2:6])
colnames(MANOVA_DATASET) <- c("Class", col)

names(MANOVA_DATASET)
```

```{r,echo = T,  warning = F}
col <- names(MANOVA_DATASET[2:6])
colnames(MANOVA_DATASET) <- c("Class", col)

names(MANOVA_DATASET)
```

-   **Septième étape :**

```{r,   warning = F}
MANOVA_DATASET$Class <- substr(as.character(MANOVA_DATASET$Class), 1, 2)
data <- MANOVA_DATASET[,c(2,3,4,5,6,1)]

data %>% kbl(digits=3) %>%    
       kable_styling(bootstrap_options = "striped", full_width = T, position = "center", latex_options = 'stripped')
```

Résultat attendu du nouveau dataset après la création de notre pipeline
ELT (Extract-Load-Transform) :

```{r, echo=FALSE, fig.width = 4, fig.height = 4, fig.align = 'center'}
knitr::include_graphics('dataset.jpg')
```

<br>

-   **Nombre total d'individus *N***

```{r N}
N <- nrow(data)
```

<br>

-   **Nombre de variables prédictives *P***

Le calcul du nombre de variables prédictives doit être réalisé de
manière automatique. Pour y parvenir, on peut, par exemple, identifier
les colonnes des variables numériques et calculer la longueur du vecteur
des identifiants (utilisation des fonctions *which* et *sapply*)

```{r P}
# à compléter
num_col <- which(sapply(MANOVA_DATASET, is.numeric))
P <- length(num_col)
```

<br>

-   **Le dataframe *X* des variables prédictives**

```{r X}
# à compléter
X <- data[-6]
```

<br>

-   **Variable catégorielle sous forme d'un vecteur *Y***

```{r Y}
Y <- data[6]
```

<br>

-   **Variable *K* qui correspond aux nombres de groupes (catégories)**

```{r K}
K <- length(unique(data$Class))
```

<br>

-   **Liste *XK* dont chaque élément contient les individus de chaque
    groupes**

Pour y parvenir, nous pouvons utiliser la fonction *split*. Les éléments
sont les suivants :

```{r Xk_1 }
# à compléter
XK <- split(data, data$Class)
head(XK)
```

<br>

<br>

-   **Vecteur *NK* qui correspond aux nombres d'individus par groupe**

```{r, NK}
NK <- sapply(XK, nrow)
print(NK)
```

-   **Liste *GK* dont chaque élément contient la moyenne des variables
    de chaque groupe (catégorie)**

```{r GK}
# à compléter
# Diviser les données en groupes basés sur la colonne "Class"
var <- split(data[-6], data$Class)

# Calculer la moyenne pour chaque groupe
GK <- sapply(var, function(group) colMeans(group, na.rm = TRUE))
GK <- as.data.frame(GK)
# Afficher les moyennes pour chaque groupe
print(GK)
```

<br>

-   **Vecteur *G* dont chaque élément est la moyenne générale (hors
    groupe) de chaque variable**

```{r G}
G <- sapply(data[-6], mean)
View(G)
```

<br>

<hr style="border: 1px  solid gray">

### <FONT color='#0066CC'><FONT size = 4> 4. Calcul des Inerties </FONT></FONT>

#### <FONT color='#0066CC'><FONT size = 4> 4.1 Inertie totale </FONT></FONT>

La Somme des carrés totaux (Inertie Totale) correspond à la sommes des
carrés des distances entre l'ensemble des observations et la moyenne
générale :

$${I_{total}} = \sum\limits_{i = 1}^n {{d^2}({x_i},g)} $$

Nous pouvons la calculer directement à l'aide du calcul matriciel
suivant : $${I_{Tot}} = SST = {(X - G)^t} \times (X - G)$$

Pour y parvenir nous devons :

1.  Transformer le dataframe en matrice (NxP)
2.  Créer une matrice de même taille (NxP) dont chaque ligne correspond
    au vecteur G
3.  Calculer la différence
4.  Effectuer la multiplication avec transposition du premier élément

Au finale, la matrice (*SS_tot*) est la suivante :

```{r I_Tot}
# à compléter
X <- t(as.matrix(X))
G <- matrix(G)
Gk <- matrix(GK)

View(G)
View(X)
View(GK)

G.mat <- matrix(G,nrow = 5,ncol = N)

dif <- X-G.mat

SS_TOT<- t(dif) %*% (dif)
print(SS_TOT)

dim(SS_TOT)   # 26 * 26
```

```         
```

#### <FONT color='#0066CC'><FONT size = 4> 4.2 Inertie intra classe </FONT></FONT>

Nous allons, dans un premier temps calculer, pour chaque groupe, la
somme des carrés des écarts entre les individus de ce groupe et la
moyenne de chaque groupe. Les Inerties intra partielles sont stockées
dans une liste (*SS_partiel_Intra*).

Pour chaque classe, nous calculons la SS intra (partielle) :
$$S{S_{{\text{k}}{\text{, intra}}}} = \sum\limits_{i = 1}^{{n_k}} {{d^2}({x_{i,j}},{g_j})}  = {({X_{ik}} - {G_k})^t} \times ({X_{ik}} - {G_k})$$

Les résultats sont les suivants:

```{r}
# à compléter
# Diviser les données en groupes basés sur la colonne "Class"
groups <- split(data[-6], data$Class)

# Calculer la matrice des différences pour chaque groupe
dif_list <- lapply(groups, function(group) {
  group_mat <- as.matrix(group)
  group_mean <- colMeans(group_mat)
  group_dif <- group_mat - matrix(group_mean, nrow = nrow(group_mat), ncol = ncol(group_mat), byrow = TRUE)
  return(group_dif)
})

# Calculer la somme des carrés des différences pour chaque groupe
SS_partiel_Intra <- lapply(dif_list, function(dif) {
  SS <- sum(dif^2)
  return(SS)
})

SS_partiel_Intra
```

<br>

Les K matrices sont ensuite additionnées pour obtenir l'inertie Intra
(*SS_Intra*),

$$S{S_{{\text{intra }}}} = \sum\limits_{j = 1}^k {\sum\limits_{i = 1}^{{n_k}} {{d^2}({x_{i,j}},{g_j})} }  = \sum\limits_{j = 1}^k {{{({X_{ik}} - {G_k})}^t} \times ({X_{ik}} - {G_k})} $$

```{r SS_Intra}
# à compléter
SS_Intra <- colSums(SS_partiel_Intra)
head(SS_Intra)
```

#### <FONT color='#0066CC'><FONT size = 4> 4.3 Inertie inter classe </FONT></FONT>

L'inertie inter classe s'obtient directement par différence.

$$S{S_{{\text{inter}}}} = S{S_{tot}} - S{S_{{\text{intra}}}}$$

```{r SS_inter}
# à compléter
SS_Inter = SS_partiel_Intra - SS_Intra
print(SS_Inter)
```

<br>

<hr style="border: 1px  solid gray">

### <FONT color='#0066CC'><FONT size = 4> 5. Inférence Statistique </FONT></FONT>

#### <FONT color='#0066CC'><FONT size = 4> 5.1 Calcul du Lambda</FONT></FONT>

$$\Lambda  = \frac{{\left| {{I_W}} \right|}}{{\left| {{I_B} + {I_W}} \right|}} = \frac{{\left| {S{S_{{\text{intra}}}}} \right|}}{{\left| {S{S_{{\text{inter}}}} + S{S_{{\text{intra}}}}} \right|}}$$

```{r, lam}
# à compléter

```

#### <FONT color='#0066CC'><FONT size = 4> 5.2 Correction </FONT></FONT>

$$ - \left( {n - 1 - \frac{{P + K}}{2}} \right)\ln (\Lambda )$$

```{r}
# à compléter
```

#### <FONT color='#0066CC'><FONT size = 4> 5.3 Conclusions </FONT></FONT>

-   La valeur corrigée suit un Chi-deux à P(K-1) degrés de liberté. Pour
    calculer la valeur critique on utilise la fonction *qchisq*. On
    prendra un risque de première espèce de 5%

```{r}
# à compléter
```

La valeur critique est très inférieure à la valeur corrigée. En
conclusion, on rejette l'hypothèse nulle d'égalité des moyennes. On peut
donc affirmer que les catégories différent très significativement. Au TD
III partie 2, nous allons réaliser le même type de test sur des plans
factoriels (Analyse Factorielle Discriminante) ce qui permettra
d'obtenir des représentations graphiques de positionnement des
différents groupes et des variables associées qui sont essentielles pour
de la fouille de données qu'elles soient réalisées en R ou en Python !

<br>

<hr style="border: 1px  solid gray">

### <FONT color='#0066CC'><FONT size = 4> 6 Validation </FONT></FONT>

Nous comparons maintenant les résultats avec la fonction manova\* de R

```{r, echo = T}
# à compléter
```

-   Comme on peut le constater, on retrouve bien la valeur corrigée
    (0.0123). Les tests ici sont différents (plus compliqués) mais
    conduisent aux mêmes résultats

### <FONT color='#0066CC'><FONT size = 4> 7 Fonctions </FONT></FONT>

A partir du code que vous avez développé, construire une fonction
générique (*MANOVA*) qui retourne sous forme de listes :

-   SS_tot
-   SS_Intra
-   SS_Inter
-   Gk
-   G
-   NK
-   P
-   N
-   Lambda
-   La probabilité associés au test(cf cours)

Nous testons cette fonction avec le fichier *iris* fourni par defaut
dans R Cette fonction nous servira au prochain TD lorsque nous
réaliserons une analyse factorielle discriminante

```{r}
# à compléter

```

Le jeux de données est le suivant

```{r}
# à compléter
```

```{r, echo = T}
# à compléter
```

<br>

l'utilisation de la fonction *manova* de R conduit à la même valeur du
lambda... Une fois de plus, vous avez bien travaillé !

```{r, echo = T}
# à compléter
```
